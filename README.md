# PassportAuthentication



Understanding PassportAuthentication created by Marlon Mora

For purposes of organization the files are labeled from top to bottom. 

Develop Folder 

First up is our middleware folder which holds the isAuthenticated file. isAuthenticated includes module.exports = function(req, res, next) . Here module.exports is defined as a function using parameters request response and keyword next. In this example if the user is logged in already upon getting into the page then he or she is taken to a dashboard or anything but a login page. There is also an “else” of sorts asking for the user to be redirected to the login page in case he or she is not logged in. Our config.json holds an object using development, test, and production keys. Mainly this stores your ability to connect your mysql server through the password key’s value by changing the value to your password. The database there is also important as it will be the name of your created database. Passport.js(passport.js) is an npm package and runs as a password validator. A function for parameters password and email is formed with a keyword parameter done to validate first an email entry. If a matching email is not found then “passport” creates an "Incorrect email." message in the if section of the else if statement. If a matching email is found then “passport” sees if the password given is incorrect. Then an “incorrect password” prompt is created from the else if statement. If none of the above is the case then the user gets returned as “dbUser”. In the models folder we have index.js which starts asking through an if part of an if else statement if there is a use_env_variable running through the config.json file. Since there is no use_env_variable we jump to the else part of the if else statement and use var sequelize = new Sequelize(config.database, config.username, config.password, config); . Now we jump to the ‘fs’ filesystem where readdirSync(__dirname) creates a filter to return any file within the folder ending in a “.js” using  return (file.indexOf('.') !== 0) && (file !== basename) && (file.slice(-3) === '.js'); . Also implicated is a function that creates a model through sequelize from  code in the file in this case user.js. we use var model = sequelize['import'](path.join(__dirname, file));  db[model.name] = model; . This imports ‘model’ as data from the objects defined in users.js using sequelize users to the given directory name (dirname).The user.js file creates a database under sequelize.define(“User”, { email: { type: DataTypes.STRING, allowNull: false, unique: true, validate: {  isEmail: true}}, which also uses a password object . Now User is defined as an email and password. User.js also incorporates the use of bcrypt using the Hook method which returns a hashed password when a password is created for protection. For the public folder inside we have login.js initializing with variables for the input password id, input email id, and form login class all in template literal format. loginForm.on(“submit”, …)  is used to return two choices from an if statement asking if the user added email or password, run the loginUser function then clear the form. loginUser then gets used to create a post to redirect members on the site after a successful login using function loginUser(email, password) { $.post("/api/login", . Now members.js makes a get request on user_data within the api and receives the email used and renders to the html assigning the email to .member-name from data.email. Also within public and js folders is signup.js. Here we have the same structure used as in login.js but the signupUser function makes a post to /api/signup instead. There is also a .catch(handleLoginErr); in place to create a 500 error message if the members route cannot be traced. Next we have login.html, signup.html, and members.html. These all contain the corresponding code needed to render the website using id and class names specifically helpful in creating dynamic input and form tags. Api-routes.js within the routes folder brings everything together by creating an app.post(“api/signup” where data is created inside of db.User using the signup information from signup.js also including a .catch incase of an error. Then html-routes.js simply creates the routes for the signup page as “/” and the login page as  “/login” under the assertion that if the user already has an account he is to be sent to the members page. The middleware isAuthenticated is also put in place to check for any login that is not found to be redirected to the signup page.
